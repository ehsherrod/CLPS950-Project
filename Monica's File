Screen('Preference', 'SkipSyncTests', 1);
% Clear the workspace and the screen
sca;
close all;
clear;

% Here we call some default settings for setting up Psychtoolbox
PsychDefaultSetup(2);

% Get the screen numbers. This gives us a number for each of the screens
% attached to our computer.
% For help see: Screen Screens?
screens = Screen('Screens');

% Draw we select the maximum of these numbers. So in a situation where we
% have two screens attached to our monitor we will draw to the external
% screen. When only one screen is attached to the monitor we will draw to
% this.
% For help see: help max
screenNumber = max(screens);

% Define black and white (white will be 1 and black 0). This is because
% in general luminace values are defined between 0 and 1 with 255 steps in
% between. With our setup, values defined between 0 and 1.
white = WhiteIndex(screenNumber);
black = BlackIndex(screenNumber);
grey = white / 2;

%CHANGE SCREENSIZE
screensize = [0 0 600 400];

% Open an on screen window and color it black
% For help see: Screen OpenWindow?
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, black, screensize);

% Get the size of the on screen window in pixels
% For help see: Screen WindowSize?
[screenXpixels, screenYpixels] = Screen('WindowSize', window);

% Get the centre coordinate of the window in pixels
% For help see: help RectCenter
[xCenter, yCenter] = RectCenter(windowRect);


% Get the size of the on screen window in pixels
% For help see: Screen WindowSize?
[screenXpixels, screenYpixels] = Screen('WindowSize', window);

% Make a base Rect of 200 by 200 pixels. This is the rect which defines the
% size of our square in pixels. Rects are rectangles, so the
% sides do not have to be the same length. The coordinates define the top
% left and bottom right coordinates of our rect [top-left-x top-left-y
% bottom-right-x bottom-right-y]. The easiest thing to do is set the first
% two coordinates to 0, then the last two numbers define the length of the
% rect in X and Y. The next line of code then centers the rect on a
% particular location of the screen.
%baseRect will be our indivudal images/figure
baseRect = [0 0 200 200];

% Center the rectangle on the centre of the screen using fractional pixel
% values.
% For help see: CenterRectOnPointd
centeredRect = CenterRectOnPointd(baseRect, xCenter, yCenter);
%% FIRST TRIAL 
rectColor = [1 1 0]; % Define YELLOW square...(this will be replaced by the actual images)
Screen('FillRect', window, rectColor, centeredRect);% Display YELLOW square...
Screen('Flip', window);
WaitSecs(2);

% Draw text in the upper portion of the screen in Times in black
Screen('TextSize', window, 20);
Screen('TextFont', window, 'Times');
DrawFormattedText (window, 'RESPONSE PAGE','center', screenYpixels*0.35, white);

% Flip to the screen
Screen('Flip', window);

% improve portability of your code acorss operating systems 
KbName('UnifyKeyNames');
% specify key names of interest in the study
activeKeys = [KbName('space')];
% set value for maximum time to wait for response (in seconds)
t2wait = 2; 
% if the wait for presses is in a loop, 
% then the following two commands should come before the loop starts
% restrict the keys for keyboard input to the keys we want
RestrictKeysForKbCheck(activeKeys);
% suppress echo to the command line for keypresses
ListenChar(2);
% get the time stamp at the start of waiting for key input 
% so we can evaluate timeout and reaction time
% tStart can also be the timestamp for the onset of the stimuli, 
% for example the VBLTimestamp returned by the 'Flip'
tStart = GetSecs;
% repeat until a valid key is pressed or we time out
timedout = false;
% initialise fields for rsp variable 
% that would contain details about the response if given
rsp.RT = NaN; 
rsp.keyCode = [];
rsp.keyName = [];
score  = 0;
while ~timedout
    % check if a key is pressed
    % only keys specified in activeKeys are considered valid
    [ keyIsDown, keyTime, keyCode ] = KbCheck; 
      if(keyIsDown) 
          score = score+1;
          break 
      end
      if( (keyTime - tStart) > t2wait)
          timedout = true
      end
  end
  % store code for key pressed and reaction time
  if(~timedout)
      rsp.RT      = keyTime - tStart;
      rsp.keyCode = keyCode;
      rsp.keyName = KbName(rsp.keyCode);
  end
score
% if the wait for presses is in a loop, 
% then the following two commands should come after the loop finishes
% reset the keyboard input checking for all keys
RestrictKeysForKbCheck;
% re-enable echo to the command line for key presses
% if code crashes before reaching this point 
% CTRL-C will reenable keyboard input
ListenChar(1)
%Screen('FillRect', window, rectColor, centeredRect);% Display black square...
Screen('Flip', window);
WaitSecs(2);

%% SECOND TRIAL
rectColor = [0 0 1]; % Define blue square...(this will be replaced by the actual images)
Screen('FillRect', window, rectColor, centeredRect);% Display blue square...
Screen('Flip', window);
WaitSecs(2);

% Draw text in the upper portion of the screen in Times in black
Screen('TextSize', window, 20);
Screen('TextFont', window, 'Times');
DrawFormattedText (window, 'RESPONSE PAGE','center', screenYpixels*0.35, white);

% Flip to the screen
Screen('Flip', window);

% improve portability of your code acorss operating systems 
KbName('UnifyKeyNames');
% specify key names of interest in the study
activeKeys = [KbName('space')];
% set value for maximum time to wait for response (in seconds)
t2wait = 2; 
% if the wait for presses is in a loop, 
% then the following two commands should come before the loop starts
% restrict the keys for keyboard input to the keys we want
RestrictKeysForKbCheck(activeKeys);
% suppress echo to the command line for keypresses
ListenChar(2);
% get the time stamp at the start of waiting for key input 
% so we can evaluate timeout and reaction time
% tStart can also be the timestamp for the onset of the stimuli, 
% for example the VBLTimestamp returned by the 'Flip'
tStart = GetSecs;
% repeat until a valid key is pressed or we time out
timedout = false;
% initialise fields for rsp variable 
% that would contain details about the response if given
rsp.RT = NaN;
rsp.keyCode = [];
rsp.keyName = [];
while ~timedout
    % check if a key is pressed
    % only keys specified in activeKeys are considered valid
    [ keyIsDown, keyTime, keyCode ] = KbCheck; 
      if(keyIsDown) 
          score = score+1;
          break
      end
      if( (keyTime - tStart) > t2wait)
          timedout = true 
      end
  end
  % store code for key pressed and reaction time
  if(~timedout)
      rsp.RT      = keyTime - tStart;
      rsp.keyCode = keyCode;
      rsp.keyName = KbName(rsp.keyCode);
  end
score
% if the wait for presses is in a loop, 
% then the following two commands should come after the loop finishes
% reset the keyboard input checking for all keys
RestrictKeysForKbCheck;
% re-enable echo to the command line for key presses
% if code crashes before reaching this point 
% CTRL-C will reenable keyboard input
ListenChar(1)
%Screen('FillRect', window, rectColor, centeredRect);% Display black square...
Screen('Flip', window);
WaitSecs(2);

%% THIRD TRIAL (IN THIS TRIAL, PRESSING THE SPACE BAR IS THE INCORECT RESPONSE) (im not sure why the third response page wont show??)
rectColor = [0 1 0]; % Define green square...(this will be replaced by the actual images)
Screen('FillRect', window, rectColor, centeredRect);% Display green square...
Screen('Flip', window);
WaitSecs(2);

% Draw text in the upper portion of the screen in Times in black
Screen('TextSize', window, 20);
Screen('TextFont', window, 'Times');
DrawFormattedText (window, 'RESPONSE PAGE','center', screenYpixels*0.35, white);

% Flip to the screen
Screen('Flip', window);

% improve portability of your code acorss operating systems 
KbName('UnifyKeyNames');
% specify key names of interest in the study
activeKeys = [KbName('space')];
% set value for maximum time to wait for response (in seconds)
t2wait = 2; 
% if the wait for presses is in a loop, 
% then the following two commands should come before the loop starts
% restrict the keys for keyboard input to the keys we want
RestrictKeysForKbCheck(activeKeys);
% suppress echo to the command line for keypresses
ListenChar(2);
% get the time stamp at the start of waiting for key input 
% so we can evaluate timeout and reaction time
% tStart can also be the timestamp for the onset of the stimuli, 
% for example the VBLTimestamp returned by the 'Flip'
tStart = GetSecs;
% repeat until a valid key is pressed or we time out
timedout = false;
% initialise fields for rsp variable 
% that would contain details about the response if given
rsp.RT = NaN; 
rsp.keyCode = [];
rsp.keyName = [];
while ~timedout
    % check if a key is pressed
    % only keys specified in activeKeys are considered valid
    [ keyIsDown, keyTime, keyCode ] = KbCheck; 
      if(keyIsDown) 
          score;
      else
          score = score +1;
          break
      end
      if( (keyTime - tStart) > t2wait), timedout = true; end
  end
  % store code for key pressed and reaction time
  if(~timedout)
      rsp.RT      = keyTime - tStart;
      rsp.keyCode = keyCode;
      rsp.keyName = KbName(rsp.keyCode);
  end
score
% if the wait for presses is in a loop, 
% then the following two commands should come after the loop finishes
% reset the keyboard input checking for all keys
RestrictKeysForKbCheck;
% re-enable echo to the command line for key presses
% if code crashes before reaching this point 
% CTRL-C will reenable keyboard input
ListenChar(1)
%Screen('FillRect', window, rectColor, centeredRect);% Display black square...
Screen('Flip', window);
WaitSecs(2);
%%

% Draw text in the upper portion of the screen in Times in black
Screen('TextSize', window, 20);
Screen('TextFont', window, 'Times');
DrawFormattedText(window, 'Congratulations! You have completed the task :)', 'center', screenYpixels*0.35, white);

% Draw text in the middle of the screen in Times in black
Screen('TextSize', window, 15);
Screen('TextFont', window, 'Times');
DrawFormattedText(window, sprintf('Your score: %d\n', score), 'center', screenYpixels*0.6, white); %After figuring out how to collect responses diplay here.

% Draw text in the lower portion of the screen in Times in black
Screen('TextSize', window, 10);
Screen('TextFont', window, 'Times');
DrawFormattedText(window, 'press any key to exit', 'center', screenYpixels*0.95, white);

% Flip to the screen
Screen('Flip', window);

% Query the frame duration
ifi = Screen('GetFlipInterval', window);

% Now we have drawn to the screen we wait for a keyboard button press (any
% key) to terminate the demo
KbStrokeWait;

% Clear the screen
sca;
